(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{471:function(a,r,t){"use strict";t.r(r);var e=t(4),s=Object(e.a)({},(function(){var a=this,r=a.$createElement,t=a._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"disruptor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#disruptor"}},[a._v("#")]),a._v(" Disruptor")]),a._v(" "),t("blockquote",[t("p",[a._v("Url: "),t("a",{attrs:{href:"https://ifeve.com/disruptor/",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://ifeve.com/disruptor/"),t("OutboundLink")],1)])]),a._v(" "),t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),t("h3",{attrs:{id:"它能够在一个线程里每秒处理6百万订单。业务逻辑处理器完全是运行在内存中，使用事件源驱动方式。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#它能够在一个线程里每秒处理6百万订单。业务逻辑处理器完全是运行在内存中，使用事件源驱动方式。"}},[a._v("#")]),a._v(" 它能够在一个线程里每秒处理6百万订单。业务逻辑处理器完全是运行在内存中，使用事件源驱动方式。")]),a._v(" "),t("blockquote",[t("p",[a._v("Url: "),t("a",{attrs:{href:"http://ifeve.com/lmax",target:"_blank",rel:"noopener noreferrer"}},[a._v("http://ifeve.com/lmax"),t("OutboundLink")],1)])]),a._v(" "),t("h2",{attrs:{id:"本次内容基于-version"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本次内容基于-version"}},[a._v("#")]),a._v(" 本次内容基于 version")]),a._v(" "),t("h3",{attrs:{id:"com-lmax-disruptor-3-4-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#com-lmax-disruptor-3-4-2"}},[a._v("#")]),a._v(" com.lmax:disruptor:3.4.2")]),a._v(" "),t("h2",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[a._v("#")]),a._v(" 概念")]),a._v(" "),t("h3",{attrs:{id:"无锁设计每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无锁设计每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。"}},[a._v("#")]),a._v(" 无锁设计"),t("br"),a._v("每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。")]),a._v(" "),t("h3",{attrs:{id:"元素位置定位数组长度2-n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万qps的处理速度，也需要30万年才能用完。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#元素位置定位数组长度2-n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万qps的处理速度，也需要30万年才能用完。"}},[a._v("#")]),a._v(" 元素位置定位"),t("br"),a._v("数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。")]),a._v(" "),t("h3",{attrs:{id:"环形数组结构为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#环形数组结构为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。"}},[a._v("#")]),a._v(" 环形数组结构"),t("br"),a._v("为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。")]),a._v(" "),t("h2",{attrs:{id:"核心类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心类"}},[a._v("#")]),a._v(" 核心类")]),a._v(" "),t("h3",{attrs:{id:"ringbuffer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ringbuffer"}},[a._v("#")]),a._v(" RingBuffer")]),a._v(" "),t("h4",{attrs:{id:"结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构"}},[a._v("#")]),a._v(" 结构")]),a._v(" "),t("h5",{attrs:{id:"环形数组-数组内存连续-存储事件-数据-object"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#环形数组-数组内存连续-存储事件-数据-object"}},[a._v("#")]),a._v(" 环形数组(数组内存连续),存储事件(数据)Object[]")]),a._v(" "),t("h5",{attrs:{id:"维护-自增-sequence-来获取数据的索引-查找数据-seq-buffersize-实际是位运算达到取余的效果-类似hashmap-的索引计算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#维护-自增-sequence-来获取数据的索引-查找数据-seq-buffersize-实际是位运算达到取余的效果-类似hashmap-的索引计算"}},[a._v("#")]),a._v(" 维护 自增 sequence 来获取数据的索引 查找数据;(seq%bufferSize);"),t("br"),a._v("实际是位运算达到取余的效果 类似hashMap 的索引计算")]),a._v(" "),t("h5",{attrs:{id:"对象数组实际大小-的前后都加了个buffer-pad-4-8-一个对象应用的大小-的空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象数组实际大小-的前后都加了个buffer-pad-4-8-一个对象应用的大小-的空间"}},[a._v("#")]),a._v(" 对象数组实际大小 的前后都加了个BUFFER_PAD (4/8 一个对象应用的大小)的空间")]),a._v(" "),t("h4",{attrs:{id:"读取"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#读取"}},[a._v("#")]),a._v(" 读取")]),a._v(" "),t("h5",{attrs:{id:"customer-通过-下一个要读取的位置-调用sequencebarrier-waitfor-获取最大可读取的序号-这里会执行waitstrategy-等待策略-通过获取的序列号轮休读取-消费-数据并更新消费的进度-cursored-这里可以并发消费-不会有锁和竞争"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#customer-通过-下一个要读取的位置-调用sequencebarrier-waitfor-获取最大可读取的序号-这里会执行waitstrategy-等待策略-通过获取的序列号轮休读取-消费-数据并更新消费的进度-cursored-这里可以并发消费-不会有锁和竞争"}},[a._v("#")]),a._v(" customer 通过 下一个要读取的位置 调用SequenceBarrier # waitFor 获取最大可读取的序号;"),t("br"),a._v("(这里会执行WaitStrategy 等待策略. )"),t("br"),a._v("通过获取的序列号轮休读取(消费)数据并更新消费的进度(Cursored);"),t("br"),a._v("这里可以并发消费 不会有锁和竞争;"),t("br")]),a._v(" "),t("h4",{attrs:{id:"写入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写入"}},[a._v("#")]),a._v(" 写入")]),a._v(" "),t("h5",{attrs:{id:"单个生产者"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单个生产者"}},[a._v("#")]),a._v(" 单个生产者")]),a._v(" "),t("h6",{attrs:{id:"_1-两阶段提交-two-phase-commit"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-两阶段提交-two-phase-commit"}},[a._v("#")]),a._v(" 1. 两阶段提交 (two-phase commit)")]),a._v(" "),t("h6",{attrs:{id:"_1-1-生产者需要申请-buffer-里的下一个节点-更新-next"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-生产者需要申请-buffer-里的下一个节点-更新-next"}},[a._v("#")]),a._v(" 1.1. 生产者需要申请 buffer 里的下一个节点(更新 next)")]),a._v(" "),t("h6",{attrs:{id:"_1-1-1-sequencer-next"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1-sequencer-next"}},[a._v("#")]),a._v(" 1.1.1. Sequencer.next")]),a._v(" "),t("h6",{attrs:{id:"_1-1-1-1-判断要写入的节点是否有消费者在消费-如果有就需要自旋等待"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1-1-判断要写入的节点是否有消费者在消费-如果有就需要自旋等待"}},[a._v("#")]),a._v(" 1.1.1.1. 判断要写入的节点是否有消费者在消费,如果有就需要自旋等待")]),a._v(" "),t("h6",{attrs:{id:"_1-2-当生产者向节点写完数据，提交-更新-cursore-。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-当生产者向节点写完数据，提交-更新-cursore-。"}},[a._v("#")]),a._v(" 1.2. 当生产者向节点写完数据，提交(更新 Cursore)。")]),a._v(" "),t("h5",{attrs:{id:"多个生产者"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多个生产者"}},[a._v("#")]),a._v(" 多个生产者")]),a._v(" "),t("h6",{attrs:{id:"_1-多生产者-会在提交的时候验证-cursore-必须是提交索引的前一个-才可以成功-否则自旋转"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-多生产者-会在提交的时候验证-cursore-必须是提交索引的前一个-才可以成功-否则自旋转"}},[a._v("#")]),a._v(" 1. 多生产者 会在提交的时候验证 cursore 必须是提交索引的前一个,才可以成功 否则自旋转")]),a._v(" "),t("h6",{attrs:{id:"_2-生产者在不同的时间完成数据写入，但是-ring-buffer-的内容顺序总是会遵循-nextentry-的初始调用顺序。也就是说，如果一个生产者在写入-ring-buffer-的时候暂停了，只有当它解除暂停后，其他等待中的提交才会立即执行。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-生产者在不同的时间完成数据写入，但是-ring-buffer-的内容顺序总是会遵循-nextentry-的初始调用顺序。也就是说，如果一个生产者在写入-ring-buffer-的时候暂停了，只有当它解除暂停后，其他等待中的提交才会立即执行。"}},[a._v("#")]),a._v(" 2. 生产者在不同的时间完成数据写入，但是 Ring Buffer 的内容顺序总是会遵循 nextEntry() 的初始调用顺序。也就是说，如果一个生产者在写入 Ring Buffer 的时候暂停了，只有当它解除暂停后，其他等待中的提交才会立即执行。")]),a._v(" "),t("a",{attrs:{name:"173D66C1382A"}},[a._v("\n### Sequence\n"),t("h4",{attrs:{id:"通过顺序递增的序号来编号管理通过其进行交换的数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通过顺序递增的序号来编号管理通过其进行交换的数据"}},[a._v("#")]),a._v(" 通过顺序递增的序号来编号管理通过其进行交换的数据")]),a._v(" "),t("h4",{attrs:{id:"防止不同的-sequence-之间的cpu缓存伪共享-flase-sharing-问题。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#防止不同的-sequence-之间的cpu缓存伪共享-flase-sharing-问题。"}},[a._v("#")]),a._v(" 防止不同的 Sequence 之间的CPU缓存伪共享(Flase Sharing)问题。")]),a._v(" "),t("p",[t("em",[a._v("Related to: "),t("a",{attrs:{href:"#173D66CF5EFA"}},[a._v("伪共享")])])]),a._v(" "),t("h3",{attrs:{id:"sequencer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sequencer"}},[a._v("#")]),a._v(" Sequencer")]),a._v(" "),t("h4",{attrs:{id:"继承树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承树"}},[a._v("#")]),a._v(" 继承树")]),a._v(" "),t("h5",{attrs:{id:""}},[t("a",{staticClass:"header-anchor",attrs:{href:"#"}},[a._v("#")]),a._v(" "),t("img",{attrs:{src:"http://resource.zhairuihao.show/blog/disruptor%E6%88%AA%E5%B1%8F2020-08-10%20%E4%B8%8A%E5%8D%8811.16.13.png",alt:"alt 属性文本"}})]),a._v(" "),t("h4",{attrs:{id:"职责"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#职责"}},[a._v("#")]),a._v(" 职责")]),a._v(" "),t("h5",{attrs:{id:"定义在生产者和消费者之间快速、正确地传递数据的并发算法。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义在生产者和消费者之间快速、正确地传递数据的并发算法。"}},[a._v("#")]),a._v(" 定义在生产者和消费者之间快速、正确地传递数据的并发算法。")]),a._v(" "),t("h5",{attrs:{id:"维护-ringbuffer-的索引获取-生产者需要先获取索引-才可以生产数据填入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#维护-ringbuffer-的索引获取-生产者需要先获取索引-才可以生产数据填入"}},[a._v("#")]),a._v(" 维护 ringbuffer 的索引获取 , 生产者需要先获取索引,才可以生产数据填入")]),a._v(" "),t("h5",{attrs:{id:"维护cursor-游标sequence-即-最快生产者生产的的位置索引-提供读取方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#维护cursor-游标sequence-即-最快生产者生产的的位置索引-提供读取方法"}},[a._v("#")]),a._v(" 维护cursor(游标sequence,即 最快生产者生产的的位置索引), 提供读取方法")]),a._v(" "),t("p",[t("em",[a._v("Related to: "),t("a",{attrs:{href:"#173D66C1382A"}},[a._v("Sequence")])])]),a._v(" "),t("h5",{attrs:{id:"维护消费者消费索引数组-当生产者遇到消费者占用的索引时-执行等待策略-自旋-等消费者完成时-在返回给生产者"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#维护消费者消费索引数组-当生产者遇到消费者占用的索引时-执行等待策略-自旋-等消费者完成时-在返回给生产者"}},[a._v("#")]),a._v(" 维护消费者消费索引数组,当生产者遇到消费者占用的索引时  执行等待策略 自旋,等消费者完成时 在返回给生产者")]),a._v(" "),t("h4",{attrs:{id:"singleproducersequencer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#singleproducersequencer"}},[a._v("#")]),a._v(" SingleProducerSequencer")]),a._v(" "),t("h4",{attrs:{id:"multiproducersequencer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#multiproducersequencer"}},[a._v("#")]),a._v(" MultiProducerSequencer")]),a._v(" "),t("h5",{attrs:{id:"int-availablebuffer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#int-availablebuffer"}},[a._v("#")]),a._v(" int[] availableBuffer")]),a._v(" "),t("h6",{attrs:{id:"_1-维护-ringbuffer的状态-是否可读-是否完成了写入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-维护-ringbuffer的状态-是否可读-是否完成了写入"}},[a._v("#")]),a._v(" 1. 维护 ringbuffer的状态 是否可读,是否完成了写入")]),a._v(" "),t("h3",{attrs:{id:"sequencebarrier"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sequencebarrier"}},[a._v("#")]),a._v(" SequenceBarrier")]),a._v(" "),t("h4",{attrs:{id:"获取发布后的的-ringbuffer-sequence-序号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#获取发布后的的-ringbuffer-sequence-序号"}},[a._v("#")]),a._v(" 获取发布后的的 ringBuffer sequence 序号")]),a._v(" "),t("h4",{attrs:{id:"状态变更提醒"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#状态变更提醒"}},[a._v("#")]),a._v(" 状态变更提醒")]),a._v(" "),t("h4",{attrs:{id:"消费者等待策略-执行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消费者等待策略-执行"}},[a._v("#")]),a._v(" 消费者等待策略 执行")]),a._v(" "),t("h3",{attrs:{id:"waitstrategy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#waitstrategy"}},[a._v("#")]),a._v(" WaitStrategy")]),a._v(" "),t("h4",{attrs:{id:"消费者等待策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消费者等待策略"}},[a._v("#")]),a._v(" 消费者等待策略")]),a._v(" "),t("h3",{attrs:{id:"eventprocessor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#eventprocessor"}},[a._v("#")]),a._v(" EventProcessor")]),a._v(" "),t("h4",{attrs:{id:"持有特定消费者-consumer-的-sequence，并提供用于调用事件处理实现的事件循环-event-loop-调用-eventhandler。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#持有特定消费者-consumer-的-sequence，并提供用于调用事件处理实现的事件循环-event-loop-调用-eventhandler。"}},[a._v("#")]),a._v(" 持有特定消费者(Consumer)的 Sequence，并提供用于调用事件处理实现的事件循环(Event Loop) 调用 EventHandler。")]),a._v(" "),t("h3",{attrs:{id:"eventhandler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#eventhandler"}},[a._v("#")]),a._v(" EventHandler")]),a._v(" "),t("h4",{attrs:{id:"定义的事件处理接口，由用户实现，用于处理事件，是-consumer-的真正实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义的事件处理接口，由用户实现，用于处理事件，是-consumer-的真正实现"}},[a._v("#")]),a._v(" 定义的事件处理接口，由用户实现，用于处理事件，是 Consumer 的真正实现")]),a._v(" "),t("h3",{attrs:{id:"consumerrepository"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#consumerrepository"}},[a._v("#")]),a._v(" ConsumerRepository")]),a._v(" "),t("h4",{attrs:{id:"维护消费者调用链as-c-需要等待-a-c-完成后执行-a-c-的执行结果存储在-ringbuffer-中"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#维护消费者调用链as-c-需要等待-a-c-完成后执行-a-c-的执行结果存储在-ringbuffer-中"}},[a._v("#")]),a._v(" 维护消费者调用链as :c 需要等待 a,c 完成后执行 (a,c 的执行结果存储在 ringbuffer 中)")]),a._v(" "),t("h2",{attrs:{id:"补充"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#补充"}},[a._v("#")]),a._v(" 补充")]),a._v(" "),t("h3",{attrs:{id:"缓存行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存行"}},[a._v("#")]),a._v(" 缓存行")]),a._v(" "),t("pre",[a._v("缓存是由缓存行组成的，缓存行是2的整数幂个连续字节，一般为32-256个字节,\n通常是64字节，并且它有效地引用主内存中的一块地址。\n一个Java的long类型是8字节，因此在一个缓存行中可以存8个long类型的变量。\n对缓存的操作通常是以一整个缓存为单位进行的, 所有一个写频繁的变量独占一个缓存行可以提高效率;\n可以通过填充的方式占满一个缓存行;\n")]),a._v(" "),t("a",{attrs:{name:"173D66CF5EFA"}},[a._v("\n#### 伪共享\n"),t("h5",{attrs:{id:"如果两个独立的线程同时写两个不同的值-内存地址相邻-在同一个缓存行上-会更糟。因为每次线程对缓存行进行写操作时，每个内核都要把另一个内核上的缓存块无效掉并重新读取里面的数据。你基本上是遇到两个线程之间的写冲突了，尽管它们写入的是不同的变量。这就造成和缓存一直是失效的状态-就是伪共享的情况"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如果两个独立的线程同时写两个不同的值-内存地址相邻-在同一个缓存行上-会更糟。因为每次线程对缓存行进行写操作时，每个内核都要把另一个内核上的缓存块无效掉并重新读取里面的数据。你基本上是遇到两个线程之间的写冲突了，尽管它们写入的是不同的变量。这就造成和缓存一直是失效的状态-就是伪共享的情况"}},[a._v("#")]),a._v(" 如果两个独立的线程同时写两个不同的值(内存地址相邻,在同一个缓存行上)会更糟。"),t("br"),a._v("因为每次线程对缓存行进行写操作时，"),t("br"),a._v("每个内核都要把另一个内核上的缓存块无效掉并重新读取里面的数据。"),t("br"),a._v("你基本上是遇到两个线程之间的写冲突了，尽管它们写入的是不同的变量。"),t("br"),a._v("这就造成和缓存一直是失效的状态 就是伪共享的情况.")]),a._v(" "),t("h4",{attrs:{id:"缓存行填充"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存行填充"}},[a._v("#")]),a._v(" 缓存行填充")]),a._v(" "),t("h5",{attrs:{id:"你会看到disruptor消除这个问题，至少对于缓存行大小是64字节或更少的处理器架构来说是这样的（注：有可能处理器的缓存行是128字节，那么使用64字节填充还是会存在伪共享问题），通过增加补全-6个-long-6-8-value-1-8-对象头-2-8字节-64-来确保ring-buffer的序列号不会和其他东西同时存在于一个缓存行-因此没有伪共享，就没有和其它任何变量的意外冲突，没有不必要的缓存未命中。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#你会看到disruptor消除这个问题，至少对于缓存行大小是64字节或更少的处理器架构来说是这样的（注：有可能处理器的缓存行是128字节，那么使用64字节填充还是会存在伪共享问题），通过增加补全-6个-long-6-8-value-1-8-对象头-2-8字节-64-来确保ring-buffer的序列号不会和其他东西同时存在于一个缓存行-因此没有伪共享，就没有和其它任何变量的意外冲突，没有不必要的缓存未命中。"}},[a._v("#")]),a._v(" 你会看到Disruptor消除这个问题，至少对于缓存行大小是64字节或更少的处理器架构来说是这样的"),t("br"),a._v("（注：有可能处理器的缓存行是128字节，那么使用64字节填充还是会存在伪共享问题），"),t("br"),a._v("通过增加补全(6个 long (6*8)+ value(1*8)+对象头(2 *8字节) = 64)来确保ring buffer的序列号不会和其他东西同时存在于一个缓存行;"),t("br"),a._v("因此没有伪共享，就没有和其它任何变量的意外冲突，没有不必要的缓存未命中。")]),a._v(" "),t("h4",{attrs:{id:"java内存布局"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java内存布局"}},[a._v("#")]),a._v(" Java内存布局")]),a._v(" "),t("h5",{attrs:{id:"对于hotspot-jvm，所有对象都有两个字长的对象头。第一个字是由24位哈希码和8位标志位（如锁的状态或作为锁对象）组成的mark-word。第二个字是对象所属类的引用。如果是数组对象还需要一个额外的字来存储数组的长度。每个对象的起始地址都对齐于8字节以提高性能。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对于hotspot-jvm，所有对象都有两个字长的对象头。第一个字是由24位哈希码和8位标志位（如锁的状态或作为锁对象）组成的mark-word。第二个字是对象所属类的引用。如果是数组对象还需要一个额外的字来存储数组的长度。每个对象的起始地址都对齐于8字节以提高性能。"}},[a._v("#")]),a._v(" 对于HotSpot JVM，所有对象都有两个字长的对象头。第一个字是由24位哈希码和8位标志位"),t("br"),a._v("（如锁的状态或作为锁对象）组成的Mark Word。第二个字是对象所属类的引用。"),t("br"),a._v("如果是数组对象还需要一个额外的字来存储数组的长度。每个对象的起始地址都对齐于8字节以提高性能。")]),a._v(" "),t("pre",[a._v("因此当封装对象的时候为了高效率，对象字段声明的顺序会被重排序成下列基于字节大小的顺序：\n\ndoubles (8) 和 longs (8)\nints (4) 和 floats (4)\nshorts (2) 和 chars (2)\nbooleans (1) 和 bytes (1)\nreferences (4/8)\n<子类字段重复上述顺序>")]),a._v(" "),t("h5",{attrs:{id:"java实例数据-各个成员变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java实例数据-各个成员变量"}},[a._v("#")]),a._v(" java实例数据(各个成员变量)")]),a._v(" "),t("h6",{attrs:{id:"_1-boolean、byte-1字节short-、char-2字节int、float-4字节long、double-8字节引用类型-4-8字节-不同位数的机器有所不同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-boolean、byte-1字节short-、char-2字节int、float-4字节long、double-8字节引用类型-4-8字节-不同位数的机器有所不同"}},[a._v("#")]),a._v(" 1. boolean、byte = 1字节"),t("br"),a._v("short 、char = 2字节"),t("br"),a._v("int、float = 4字节"),t("br"),a._v("long、double = 8字节"),t("br"),a._v("引用类型 = 4/8字节(不同位数的机器有所不同)")]),a._v(" "),t("h3",{attrs:{id:"内存屏障"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障"}},[a._v("#")]),a._v(" 内存屏障")]),a._v(" "),t("pre",[a._v("它是一个CPU指令。基本上，它是这样一条指令：\n     a)确保一些特定操作执行的顺序； \n     b)影响一些数据的可见性(可能是某些指令执行后的结果)。\n\n\n编译器和CPU可以在保证输出结果一样的情况下对指令重排序，\n使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，\n后于这个命令的必须后执行。\n\n\n内存屏障另一个作用是强制更新一次不同CPU的缓存。\n例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，\n这样任何试图读取该数据的线程将得到最新值，\n而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。")]),a._v(" "),t("h4",{attrs:{id:"和-java-的-关系volatile"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#和-java-的-关系volatile"}},[a._v("#")]),a._v(" 和 java 的 关系volatile")]),a._v(" "),t("h5",{attrs:{id:"如果你的字段是volatile，java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如果你的字段是volatile，java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。"}},[a._v("#")]),a._v(" 如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。")]),a._v(" "),t("h5",{attrs:{id:"写操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写操作"}},[a._v("#")]),a._v(" 写操作")]),a._v(" "),t("h6",{attrs:{id:"_1-1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。"}},[a._v("#")]),a._v(" 1. 1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。"),t("br"),t("br"),a._v("2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，"),t("br"),a._v("因为内存屏障会把之前的写入值都刷新到缓存。")]),a._v(" "),t("h5",{attrs:{id:"缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),t("h6",{attrs:{id:"_1-内存屏障的确是有开销的-编译器-cpu不能重排序指令，导致不可以尽可能地高效利用cpu，另外刷新缓存亦会有开销。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-内存屏障的确是有开销的-编译器-cpu不能重排序指令，导致不可以尽可能地高效利用cpu，另外刷新缓存亦会有开销。"}},[a._v("#")]),a._v(" 1. 内存屏障的确是有开销的——编译器/cpu不能重排序指令，"),t("br"),a._v("导致不可以尽可能地高效利用CPU，另外刷新缓存亦会有开销。")])])])])}),[],!1,null,null,null);r.default=s.exports}}]);