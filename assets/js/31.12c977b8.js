(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{485:function(n,a,e){"use strict";e.r(a);var t=e(4),s=Object(t.a)({},(function(){var n=this,a=n.$createElement,e=n._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("集合\nCollection 接口的接口 对象的集合（单列集合）\n├——-List 接口：元素按进入先后有序保存，可重复\n│—————-├ LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全\n│—————-├ ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全\n│—————-└ Vector 接口实现类 数组， 同步， 线程安全\n│ ———————-└ Stack 是Vector类的实现类\n└——-Set 接口： 仅接收一次，不可重复，并做内部排序\n├—————-└HashSet 使用hash表（数组）存储元素\n│————————└ LinkedHashSet 链表维护元素的插入次序\n└ —————-TreeSet 底层实现为二叉树，元素排好序\nMap 接口 键值对的集合 （双列集合）\n├———Hashtable 接口实现类， 同步， 线程安全\n├———HashMap 接口实现类 ，没有同步， 线程不安全-\n│—————–├ LinkedHashMap 双向链表和哈希表实现\n│—————–└ WeakHashMap\n├ ——–TreeMap 红黑树对所有的key进行排序\n└———IdentifyHashMap")]),n._v(" "),e("p",[n._v("list，set，map简单区别\nList是一个继承于Collection的接口，即List是集合中的一种。List是有序的队列，List中的每一个元素都有一个索引；第一个元素的索引\n值是0，实现list的接口有arraylist，linkedlist, vector, Stack\nSet是一个继承于Collection的接口，Set是一种不包括重复元素的Collection。它维持它自己的内部排序，它同样运行null的存在但是仅\n有一个，实现了Set接口的集合有：HashSet、TreeSet、LinkedHashSet、EnumSet。\nMap是由一系列键值对组成的集合，提供了key到Value的映射。它不能存在相同的key值，允许key为null，当然value值可以相同。实现\nmap的集合有：HashMap、HashTable、TreeMap、WeakHashMap。\nList\nArraylist\n非线程安全。底层基于动态数组实现，扩容为 1.5 倍。在堆上是一段连续内存，直接根据“首地址+下标+字节大小”就能直\n接访问数据，所以访问查找速度会比较快；而增删会涉及到后面数组的移动，增还会涉及到判断数组的扩容，所以增删慢。\nLinkedList\n非线程安全。底层是双向链表实现。内存区域随机，每个节点都有对兄弟节点的引用指针，所以增删只对兄弟节点的引\n用指针修改即可，所以快；查找数据则需要遍历数据到指定数据，所以查找慢。\nVertor\n线程安全。和 ArrayList 一样，基于数组实现。\nSet\nHashSet\n非线程安全。内部无序，封装了 hashmap，用 hashmap 的 key 存储值，即按元素的 hash 值存储，所以无序，并且只允许一个 null 值。\nTreeSet\n非线程安全。基于 TreeMap 实现，也就是基于红黑树实现，有序。\nMap\nHashMap\n非线程安全。数组+链表（1.8 后再+红黑树）。\n原理\n数组+链表的结合体，数据结构中称为“链表散列”\nHashMap主要用来存放键值对，基于hash表的map接口实现，是常用的java集合之一。\n1.8之前\n结构\n数组+链表 组成\n头插法\n就是说新来的值会取代原有的值，原有的值就顺推到链表中去，因为写这个代码的作者认为后来的值被查找的可能性更大一点，提升查找的效率。\n扩容的时候，转移过程中修改了原来链表中节点的引用关系，可能会出现环形链表，然后出现死循环，所以多线程操作HashMap时可能引起死循环。\n1.8之后\n结构\n数组+链表+红黑树，当链表长度大于阈值8的时候会转为红黑树（前提条件是数组的长度大于等于64，否则会优先选择扩容）\n为什么需要链表\n数组长度是有限的，在有限的长度里面我们使用哈希，哈希本身就存在概率性，当hash到一个值的时候就出现了链表。每一个节点都会保存自身的hash、key、value、以及下个节点\n尾部插入\n数据在插入链表的时候总是在最后，扩容转移后链表顺序不变。\nJava8就可以把HashMap用在多线程中吗？\n不可以，源码中get和put方法都没有加锁，所以线程还是不安全。\n扩容\n什么时候会扩容\n两个因素：")]),n._v(" "),e("ul",[e("li",[n._v("Capacity：HashMap当前长度。")]),n._v(" "),e("li",[n._v("LoadFactor：负载因子，默认值0.75f。")]),n._v(" "),e("li",[n._v("1.8 中，当链表中长度大于阈值 8 的时候，如果数组长度没有大于 64 会优先选择扩容。\n比如当前的容量大小为100，当你存进第76个的时候，判断发现需要进行resize了\n扩容数组大小为原两倍大小。\n扩容流程")]),n._v(" "),e("li",[n._v("扩容：创建一个新的Entry空数组，长度是原数组的2倍。")]),n._v(" "),e("li",[n._v("ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。\n为什么要重新Hash\n因为长度扩大以后，Hash的规则也随之改变。\nHash的公式---\x3e index = HashCode（Key） & （Length - 1）\n初始化大小为什么是16")])]),n._v(" "),e("p",[n._v("PUT方法的流程")]),n._v(" "),e("ol",[e("li",[n._v("通过key计算出一个hashcode")]),n._v(" "),e("li",[n._v("通过hashcode与数组长度“与操作”计算出一个数组下标 === （n-1）&hash")]),n._v(" "),e("li",[n._v("在把put进来的key,value封装为一个entry对象")]),n._v(" "),e("li",[n._v("判断数组下标对应的位置，是不是空，如果是空则把entry直接存在该数组位置")]),n._v(" "),e("li",[n._v("如果该下标对应的位置不为空，则需要把entry插入到链表中")]),n._v(" "),e("li",[n._v("并且还需要判断该链表中是否存在相同的key，如果存在，则更新value\nHashTable\n线程安全。数组+链表，key value 都不能为 null。\nLinkedHashMap\n非线程安全。自己维护了一个双向链表，有序。相当于 hashmap+linkedlist。\nTreeMap\n非线程安全。基于红黑树实现，有序集合。--ConcurrentHashMap：线程安全。分段数组+链表实现。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);