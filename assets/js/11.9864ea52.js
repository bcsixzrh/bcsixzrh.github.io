(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{465:function(n,e,t){"use strict";t.r(e);var a=t(4),s=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[n._v("#")]),n._v(" 前言")]),n._v(" "),t("p",[n._v("闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。\n要理解闭包，首先必须理解Javascript特殊的变量作用域。\n变量的作用域无非就是两种：全局变量和局部变量。\nJavascript语言的特殊之处，就在于函数内部可以直接读取全局变量。")]),n._v(" "),t("h2",{attrs:{id:"_1-闭包-closure-demo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-闭包-closure-demo"}},[n._v("#")]),n._v(" 1. 闭包(closure) demo")]),n._v(" "),t("p",[n._v("对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。\n代码中，外部函数f1只执行了一次，变量N设为0，并将内部函数f2赋值给了变量result。\n由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，\n然而事实并不是这样：我们每次调用result的时候，\n发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("function f1(){\n    var N = 0; // N是f1函数的局部变量\n\n    function f2() // f2是f1函数的内部函数，是闭包\n    {\n        N += 1; // 内部函数f2中使用了外部函数f1中的变量N\n        console.log(N);\n    }\n    return f2;\n}\nvar result = f1();\nresult(); // 输出1result(); // 输出2result(); // 输出3\n")])])]),t("h2",{attrs:{id:"_2-模块化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-模块化"}},[n._v("#")]),n._v(" 2. 模块化")]),n._v(" "),t("p",[n._v("JavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。\n这时，可以使用立即执行函数来实现模块化，正如很多JS库比如jQuery以及我们Fundebug都是这样实现的。")]),n._v(" "),t("p",[n._v('var module = (function() {\nvar N = 5;\nfunction print(x) {\nconsole.log("The result is: " + x);\n}\nfunction add(a) {\nvar x = a + N;\nprint(x);\n}\nreturn {\ndescription: "This is description",\nadd: add\n};\n})();\nconsole.log(module.description); // 输出"this is description"\nmodule.add(5); // 输出“The result is: 10”')]),n._v(" "),t("h2",{attrs:{id:"_3-函数重载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-函数重载"}},[n._v("#")]),n._v(" 3. 函数重载")]),n._v(" "),t("p",[n._v("所谓函数重载(method overloading)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过if...else或者switch实现，这就不去管它了。jQuery之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。从效果上来说，people对象的find方法允许3种不同的输入:0个参数时，返回所有人名；1个参数时，根据firstName查找人名并返回；2个参数时，根据完整的名称查找人名并返回。难点在于，people.find只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数find0,find1与find2啊！这里的关键在于old属性。由addMethod函数的调用顺序可知，people.find最终绑定的是find2函数。然而，在绑定find2时，old为find1；同理，绑定find1时，old为find0。3个函数find0,find1与find2就这样通过闭包链接起来了。根据addMethod的逻辑，当f.length与arguments.length不匹配时，就会去调用old，直到匹配为止。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('function addMethod(object, name, f){\n    var old = object[name];　　\n    object[name] = function()    {\n         // f.length为函数定义时的参数个数\n        // arguments.length为函数调用时的参数个数　　　　\n        if (f.length === arguments.length)\n        {　　\n            return f.apply(this, arguments);　　　　\n        } else if (typeof old === "function")\n        {\n            return old.apply(this, arguments);　　　　\n        }　　\n    };\n}\n// 不传参数时，返回所有name\nfunction find0(){　\n    return this.names;\n}\n// 传一个参数时，返回firstName匹配的name\nfunction find1(firstName){　　\n    var result = [];　　\n    for (var i = 0; i < this.names.length; i++)\n    {　　　　\n        if (this.names[i].indexOf(firstName) === 0)\n        {　　　　　　\n            result.push(this.names[i]);　　　　\n        }　　\n    }　　\n    return result;\n}// 传两个参数时，返回firstName和lastName都匹配的name\nfunction find2(firstName, lastName){　\n    var result = [];　　\n    for (var i = 0; i < this.names.length; i++)\n    {　　　　\n        if (this.names[i] === (firstName + " " + lastName))\n        {　　　　　　\n            result.push(this.names[i]);　　　　\n        }　　\n    }　　\n    return result;\n}\nvar people = {　　\n    names: ["Dean Edwards", "Alex Russell", "Dean Tom"]\n};\n\n\naddMethod(people, "find", find0);\naddMethod(people, "find", find1);\naddMethod(people, "find", find2);\nconsole.log(people.find()); // 输出["Dean Edwards", "Alex Russell", "Dean Tom"]\nconsole.log(people.find("Dean")); // 输出["Dean Edwards", "Dean Tom"]\nconsole.log(people.find("Dean", "Edwards")); // 输出["Dean Edwards"]\n')])])]),t("h2",{attrs:{id:"_4-結束語"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-結束語"}},[n._v("#")]),n._v(" 4. 結束語")]),n._v(" "),t("p",[n._v("啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦")])])}),[],!1,null,null,null);e.default=s.exports}}]);